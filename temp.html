<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<meta name="layout" content="post"/>
	<meta name="author" content="Sigfried Gold"/>
	<title>&quot;supergroup&quot;</title>
	<meta name="comments" content="true"/>
	<meta name="categories" content="[repo]"/>
	<meta name="source" content="https://github.com/Sigfried/supergroup"/>
	<meta name="license" content="http://sigfried.mit-license.org/"/>
	<link type="text/css" rel="stylesheet" href="./style.css"/>
	<link type="text/css" rel="stylesheet" href="./assets/prism.css"/>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.js"></script>

<script src="./lodash/lodash.js"></script>

<script src="./supergroup.js"></script>

<!--
<script src="https://rawgit.com/Sigfried/supergroup/master/supergroup.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.2/underscore.js"></script>
<script src="../../software/d3/d3.js"></script>
-->

<p><a href="https://github.com/sigfried/supergroup"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a></p>
<div>
<section>

<h1 id="supergroup.js">Supergroup.js</h1>

<p>Supergroup brings extreme convenience and understandability to the manipulation of
Javascript data collections, especially in the context of D3.js visualization
programming.</p>

<p>As if in submission to the great programmers commandment&#8211;<em>Don&#8217;t
Repeat Yourself</em>&#8211;every time I find myself writing a piece of code
that solves basically the same problem I&#8217;ve solved a dozen times
before, a little piece of my soul dies.</p>

<p>Utilities for grouping record collections into maps or nests abound:
<a href="https://github.com/mbostock/d3/wiki/Arrays#-nest">d3.nest</a>,
<a href="https://github.com/mbostock/d3/wiki/Arrays#associative-arrays">d3.map</a>,
<a href="http://underscorejs.org/#groupBy">Underscore.groupBy</a>,
<a href="https://github.com/iros/underscore.nest">Underscore.Nest</a>, to name
a few. But after these tools relieve us of a certain amount of
repetitive stress, we&#8217;re often left with a tangle of hairy details
that fill us with a dreadful sense of deja vu. Supergroup may seem
like the kind of tacky wonder gadget you&#8217;d find on a late-night
Ronco ad, but, for the low, low price of free, it makes data-centric
Javascript programming fun again. <strong>And</strong>, when you find yourself
in a D3.js callback routine holding a datum object that might have
come from anywhere&#8211;for instance, with a tooltip callback used on
disparate object types&#8211;everything you want to know about your
object and its associated metadata and records is right there at
your fingertips.</p>

<p>Just to be clear about the problem&mdash;you start with tabular data from a CSV
file, a SQL query, or some AJAX call:</p>

<div><div class="label">Some very fake hospital data in a CSV file...</div>
<div width="100%" class="rendercode" height="110px">
    tabulate(container, data, ['Patient','Patient Age','PatientVisit','Date','Time','Unit','Physician','Charge','Copay','Insurance','Inpatient']); // # run
</div>
<div id="test"></div>
</div>

<div><div class="label">...turned into canonical array of Objects (using d3.csv, for instance)</div>
<div class="rendercode" height="200px">
    data; // #   render result.replace(/{/g,'\n   {').replace(/]/,'\n]');
</div></div>

<p>Without Supergroup, you&#8217;d group the records on the values of one or more fields
with a standard grouping function, giving you data like:</p>

<div><div class="label">d3.nest().map(data)</div>
<div class="rendercode" width="100%" height="150px">
        d3.nest().key(function(d) { return d.Physician; })
                 .key(function(d) { return d.Unit; })
                 .map(data);  // # show render indent2
</div></div>

<p>or</p>

<div markdown="0"><div class="label">d3.nest().map(data)</div>
<div class='rendercode' width="100%" height="150px">
        d3.nest().key(function(d) { return d.Physician; })
                 .key(function(d) { return d.Unit; })
                 .entries(data);  // # show render indent2 result.replace(/,\n/g, ", ").replace(/("key".*, )/g,"$1\n").replace(/,   */g, ", ")
</div></div>

<p>To my mind, these are awkward data structures (not to mention the awkwardness
of the calling functions.) The <code>map</code> version looks ok in the console, but
D3 wants data in arrays, not as objects. The <code>entries</code> version gives us
arrays of key/value pairs, but on upper levels <code>values</code> is another array of
key/value pairs while on the bottom level <code>values</code> is an array of records. In
both <code>entries</code> and <code>map</code>, you can&#8217;t tell from a node at any level what
dimension was being grouped at that level. </p>

<p>Supergroup gives you almost everything you&#8217;d want for every item in your nest
(or in your single array if you have a one-level grouping):</p>

<ul>
<li>An array of the values grouped on (could be strings, numbers, or dates) (<a href="#basics:aplainarrayofstringsenhancedwithchildrenandrecords">Basics</a>)</li>
<li>The records associated with each group</li>
<li>Parents of nested groups (<a href="#dimensionnamesandpaths">Dimension Names and Paths</a>)</li>
<li>Immediate child groups if any</li>
<li>All descendant groups (<a href="#retrievingsetsofvalues">Retrieving sets of values</a>)</li>
<li>Only descendant groups at the leaf level</li>
<li>For a group at any level, the name of the dimension (attribute, column, property, etc.) grouped on</li>
<li>Path of group names from root to current group</li>
<li>Path of group dimension names from root to current group</li>
<li>Aggregate calculations on records for that group and its descendants (<a href="#aggregates">Aggregates</a>)</li>
<li>Ability to look up specific values (<a href="#findingspecificvalues">Finding specific values</a>)</li>
<li>Any of these in a format D3 or some other tool expects (<a href="#usingsupergroupford3hierarchylayouts">Using Supergroup for D3 hierarchy layouts</a>)</li>
<li>Ability to include records in multiple groups if appropriate (<a href="#multi-valuedgroups">Multi-valued Groups</a>)</li>
</ul>

<h2 id="supergroup">Supergroup</h2>

<p>Works as an Underscore (or <a href="https://lodash.com/">Lo-Dash</a>) mixin: </p>
 <pre class="language-markup" data-src="./mixin_example.html"></pre>

<h2 id="basics:aplainarrayofstringsenhancedwithchildrenandrecords">Basics: A plain Array of Strings, enhanced with children and records</h2>

<p><code>_.supergroup(data, fieldname)</code> returns an array whose elements are the
 distinct values of <code>&lt;fieldname&gt;</code> in the original data records. These elements,
 or Values can be String or Number objects (Dates to be implemented eventually).
 Each Value holds a <code>.records</code> property which is an array containing the subset of
 original records matching that Value.</p>

<p>In the example below we do a multi-level grouping by Physician and Unit. So
 <code>sg = _.supergroup(data,['Physician','Unit'])</code> returns a list of
 physicians (the top-level grouping). The first item in this list,
 <code>sg[0]</code>, is &#8220;Adams&#8221;, a String object. <code>sg[0].records</code> is an array
 containing the records where Physician=&#8220;Adams&#8221;. <code>sg[0].children</code> is a
 list of the Units (our second-level grouping) in the records where
 Physician=&#8220;Adams&#8221;. <code>sg[0].children[0].records</code> would be the subset of
 records where Physician=&#8220;Adams&#8221; and Unit=&#8220;preop&#8221;.</p>

<p><a id='sgphysunit'></a></p>
 <div><div class="label">Supergroup on physician and unit</div>
 <div class='rendercode' width="100%" height="370px">

<pre><code>sg = _.supergroup(data, ['Physician','Unit']); // # show render
;
sg[0]  // # show render
;
sg[0].records // # show render
;
sg[0].children // show render
</code></pre>

<p></div></p>

<p></div></p>

<h2 id="dimensionnamesandpaths">Dimension names and paths</h2>

<p>When you&#8217;re using D3 for any kind of significant application, you&#8217;ll be
 writing callbacks that could accept datums of different sorts, from different
 hierarchy levels or whatever. D3 makes it super easy to pass the data values
 around, but then you spend half your time trying to reattach metadata to the
 values you&#8217;re using. Not with Supergroup:</p>

<p><a id='sgdims'></a></p>
 <div><div class='rendercode' width="100%" height="220px">
 sg[0].children[0] // # show render
 ;
 [sg[0].children[0].dim, sg[0].children.dim, sg.dim] // # show render
 ;
 sg[0].children[0].parent // # show render
 ;
 sg[0].children[0].namePath() // # show render
 ;
 sg[0].children[0].dimPath() // # show render
 </div></div>

<h2 id="aggregates">Aggregates</h2>

<p>You can apply aggregate functions to the records of a single group or
 to all the groups in a list.</p>

<p><a id='sgagg'></a></p>
 <div><div class='rendercode' width="100%" height="180px">

<pre><code>    _.each(data, function(rec) {
        rec.Charge = parseFloat(rec.Charge);
        rec.Copay = parseFloat(rec.Copay);
    });
    sg = _.supergroup(data, ['Physician','Unit']); // # run
    ;
    sg[0].aggregate(d3.sum, &quot;Charge&quot;) // # show render
    ;
    sg[0].aggregate(d3.sum, function(rec) { return rec.Charge - rec.Copay; }) // # show render
    ;
    sg.aggregates(d3.sum, &quot;Charge&quot;) // # show render
    ;
    sg.aggregates(d3.sum, &quot;Charge&quot;, &quot;dict&quot;) // # show render
</code></pre>

<p></div></div></p>

<h2 id="findingspecificvalues">Finding specific values</h2>

<p><a id='sgnodes'></a>
 <p><div class='rendercode' width="100%" height="180px" src="examples/examples.html?sgnodes"></p>

<pre><code>sg.lookup(&quot;Feldman&quot;) // # show render
;
sg.lookup(&quot;Feldman&quot;).aggregate(d3.sum,&quot;Charge&quot;) // # show render
;
sg.lookup([&quot;Gupta&quot;, &quot;pediatrics&quot;]).namePath() // # show render
;
sg.lookupMany([&quot;Baker&quot;, &quot;Doom&quot;, &quot;Feldman&quot;,&quot;A Name With No Match&quot;]) // # show render
</code></pre>

<p></div></p></p>

<h2 id="retrievingsetsofvalues">Retrieving sets of values</h2>

<p><a id='sgnodesets'></a>
 <p><div class='rendercode' width="100%" height="200px"></p>

<pre><code>sg.leafNodes()  // all bottom level groups  # show render
;
sg.flattenTree()  // all groups  # show render
;
_(sg.leafNodes()).invoke(&quot;namePath&quot;) // call .namePath() on all bottom level groups using underscore invoke  # show render
</code></pre>

<p></div></p></p>

<h2 id="usingsupergroupford3hierarchylayouts">Using Supergroup for D3 hierarchy layouts</h2>

<p>D3 <a href="https://github.com/mbostock/d3/wiki/Hierarchy-Layout">hierarchy layouts</a>
 (Cluster, Pack, Partition, Tree, Treemap) require a slightly different data
 structure than those produced by d3.nest.
 <a href="https://github.com/iros/underscore.nest">Underscore.Nest</a> does very close
 to the right thing, but Supergroup gives you a bunch of added benefits.</p>

<p>I&#8217;ll demonstrate using Supergroup in a D3 hierarchy with code from
 <a href="https://gist.github.com/mbostock/4063582">this basic div-based treemap example</a>.</p>

<p>The kind of tree D3 wants for its hierarchy layouts has a single root node and
 at the leaf level are the raw records. Except for the leaves, every node has
 a children array. On upper levels, a group node&#8217;s children are other group nodes.
 At the next-to-bottom level, the children are raw records. Supergroup generally
 considers records and children to be two different things, and the children
 of a group value are other group values. </p>

<p>So, for D3 hierarchies, we get a root node by calling <code>root = sg.asRootVal()</code>.
 Then we add a final level of raw records by calling
 <code>root.addRecordsAsChildrenToLeafNodes()</code>. Now root is ready to be used
 in a treemap. To see details, inspect code
 <a href="./examples/examples.html?sghierarchy">here</a>.</p>

<p><a id='sghierarchy'></a>
 <div><div class='rendercode' width="100%" height="370px"></p>

<pre><code>    window.root = _.supergroup(data, ['Physician','Unit']).asRootVal('All Physicians'); // # show run
    root.addRecordsAsChildrenToLeafNodes();
    var nodes = d3.layout.hierarchy()(root); // # show run
</code></pre>

<p></div></div>
 <div><div id='viz' class='rendercode' width="100%" height="370px"></p>

<pre><code>    var color = d3.scale.category20c();
    var treemap = d3.layout.treemap()
        .size([700, 400])
        .padding([18,3,3,3])
        //.value(function(d) { return d3.sum(_.pluck(d.records,'Charge'));; });
        .value(function(d) { return d.Charge })
    var div = d3.select(&quot;div#viz&quot;);
    var node = div.datum(root).selectAll(&quot;.treemapnode&quot;)
            .data(treemap.nodes)
        .enter().append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;treemapnode&quot;)
            .call(position)
            .style(&quot;background&quot;, function(d) { return d.children ? color(d) : null; })
            .text(function(d) { 
                return d.children ? d : 
                    _.chain(d).pick('Patient', 'Date', 'Charge')
                        .values().value().join(', ');
            })
            //.text(_.identity)

    function position() {
        this.style(&quot;left&quot;, function(d) { return d.x + &quot;px&quot;; })
            .style(&quot;top&quot;, function(d) { return d.y + &quot;px&quot;; })
            .style(&quot;width&quot;, function(d) { return Math.max(0, d.dx - 1) + &quot;px&quot;; })
            .style(&quot;height&quot;, function(d) { return Math.max(0, d.dy - 1) + &quot;px&quot;; });
    }
    // # run
</code></pre>

<p></div></div></p>

<h2 id="multi-valuedgroups">Multi-valued Groups</h2>

<p>Sometimes it makes sense to group on multi-valued fields, which leads
 to the result that records with multiple values in a grouped field end up
 in more than one group. It doesn&#8217;t happen often, but when it does, good
 luck getting underscore or lodash or d3.nest or anything to help you with
 the grouping. </p>

<p>One of our fake data records has two values separated by a semicolon in the
 Insurance field. We turn that field into an array. First we show that by
 default, Supergroup rejoins the array (with commas) and groups as usual,
 giving us four Insurance groups. But when we ask for multiValuedGroups,
 we only get three groups. And that one record will show up in both of
 them.</p>

<p><a id='sgmultval'></a>
 <p><div class='rendercode' width="100%" height="200px"></p>

<pre><code>    _.each(data, function(d) { d.Insurance = d.Insurance.split(';')}) //  make Insurance field an array instead of ;-delimited string  # show run
    ;
    _.supergroup(data, &quot;Insurance&quot;) // supergroup by default just makes the array back into a string, joined with comma. so, 4 Insurance groups  // show render
    ;
    _.supergroup(data, 'Insurance', {multiValuedGroup: true}); // now only 3 Insurance groups!  # show render
    ;
    mvnest = _.supergroup(data, ['Insurance','Patient'], {multiValuedGroups: ['Insurance']});
    _.invoke(mvnest.leafNodes(),'namePath') // # show render
</code></pre>

<p></div></p></p>

<p>(In order to get this to work, I exposed an internal function
 of lodash. You can see the tiny change in my <a href="https://github.com/Sigfried/lodash/commit/e158039d54d69e1362b15e8478885c4aaa23c9b2">lodash fork</a>.)</p>

<h2 id="license">License</h2>

<p>MIT: <a href="http://sigfried.mit-license.org/">http://sigfried.mit-license.org/</a></p>
</section>
</div>

<script src="assets/prism.js"></script>

<script src="./docrender.js"></script>

<script>
    d3.xhr('./examples/fake-patient_data.csv', function(err, resp) {
        csv = resp.response;
        data = d3.csv.parse(csv);
        render();
        /*
        d3.selectAll('div.showandruncode')
            .each(function(d) {
                var div = d3.select(this);
                var html = div.html();
                div.html('');
                div.append('div').attr('class','showcode').html(html);
                div.append('div').attr('class','runcode').html(html);
            });
        d3.selectAll('div.showcode')
            .each(function(d) {
                putcode(d3.select(this));
            });
        d3.selectAll('div.runcode')
            .each(function(d) {
                putcode(d3.select(this), true);
            });
        */
    });
</script>

</body>
</html>
